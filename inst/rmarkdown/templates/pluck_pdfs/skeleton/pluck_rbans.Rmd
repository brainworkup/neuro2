---
title: "Create RBANS .csv files"
params:
  patient: "Presley"
  test:
    label: "Test"
    value: rbans
    input: select
    multiple: no
    choices:
      - rbans
      - rbans_a
      - rbans_b
      - rbans_c
      - rbans_d
  test_name:
    label: "Test Name"
    value: "RBANS Update Form B"
    input: select
    multiple: no
    choices: ["RBANS ", "RBANS Update Form A ", "RBANS Update Form B ", "RBANS Update Form C ", "RBANS Update Form D "]
  file:
    label: "No file selected"
    value: file
    input: file
  line_orientation_pct_rank:
    label: "Line Orientation %ile"
    value: 13
    input: numeric
  picture_naming_pct_rank:
    label: "Picture Naming %ile"
    value: 37
    input: numeric
  list_recall_pct_rank:
    label: "List Recall %ile"
    value: 37
    input: numeric
  list_recognition_pct_rank:
    label: "List Recognition %ile"
    value: 63
    input: numeric
  eval: TRUE
output:
  rmdformats::robobook:
    highlight: kate
---

# Data

Export raw CSV file from Q-interactive using "download files".

**Note**: If you encounter Java issues with this RMarkdown file, consider using the `process_rbans_data()` function from `pluck_neuropsych_pdfs.R` instead, which provides the same functionality with better error handling:

# Setup

```{r setup, include=F}
# Configure Java environment for RStudio
java_homes <- c(
  "/Library/Java/JavaVirtualMachines/graalvm-community-openjdk-22.0.1+8.1/Contents/Home",
  "/Library/Java/JavaVirtualMachines/openjdk-21.jdk/Contents/Home",
  "/Library/Java/JavaVirtualMachines/openjdk-17.jdk/Contents/Home",
  "/Library/Java/JavaVirtualMachines/openjdk-11.jdk/Contents/Home",
  "/usr/libexec/java_home"
)

# Find working Java installation
java_home <- NULL
for (path in java_homes) {
  if (dir.exists(path) || path == "/usr/libexec/java_home") {
    if (path == "/usr/libexec/java_home") {
      # Try to get system default Java
      tryCatch({
        java_home <- system("/usr/libexec/java_home", intern = TRUE)
        if (dir.exists(java_home)) break
      }, error = function(e) NULL)
    } else if (dir.exists(path)) {
      java_home <- path
      break
    }
  }
}

# Set Java environment if found
if (!is.null(java_home)) {
  Sys.setenv(JAVA_HOME = java_home)
  options(java.parameters = "-Xmx8000m")
  cat("Java configured at:", java_home, "\n")
} else {
  cat("Warning: No Java installation found. Some functions may not work.\n")
}

knitr::opts_chunk$set(
  root.dir = normalizePath("./"),
  echo = FALSE,
  eval = TRUE,
  include = TRUE,
  message = FALSE,
  warning = FALSE,
  error = TRUE
)

# Load non-Java dependent libraries first
library(tidyverse)
library(here)
library(magrittr)
library(glue)
library(neuro2)

# Try to load Java-dependent libraries with error handling
tryCatch({
  library(rJava)
  library(tabulapdf)
  java_available <- TRUE
}, error = function(e) {
  cat("Warning: Java-dependent packages not available:", e$message, "\n")
  cat("Consider using the process_rbans_data() function from pluck_neuropsych_pdfs.R instead.\n")
  java_available <<- FALSE
})

# Load other libraries
suppressPackageStartupMessages({
  if (requireNamespace("shiny", quietly = TRUE)) library(shiny)
  if (requireNamespace("pdftools", quietly = TRUE)) library(pdftools)
  if (requireNamespace("googledrive", quietly = TRUE)) library(googledrive)
})
```

# Parameters

```{r patient}
patient <- params$patient
test <- params$test
test_name <- params$test_name
test_name_prefix <- params$test_name
# input_file_path <- file.path(file.choose())
input_file_path <- file.path(params$file)
saveRDS(input_file_path, paste0(test, "_path.rds"))
input_file_path <- readRDS(paste0(test, "_path.rds"))
```

## RAW SCORES

```{r}
# Define output file path for raw scores
output_file_path <- "data-raw/processed_rbans_raw_data.csv"

df <- tryCatch(
  {
    suppressWarnings(
      readr::read_csv(
        input_file_path,
        col_names = FALSE,
        col_types = readr::cols(.default = "c"),
        show_col_types = FALSE,
        locale = readr::locale(encoding = "UTF-16LE"),
        skip_empty_rows = TRUE,
        trim_ws = TRUE,
        na = c("", "NA", "N/A", "-")
      )
    )
  },
  error = function(e) {
    # If read_csv fails, try with different encoding
    suppressWarnings(
      readr::read_csv(
        input_file_path,
        col_names = FALSE,
        col_types = readr::cols(.default = "c"),
        show_col_types = FALSE,
        skip_empty_rows = TRUE,
        trim_ws = TRUE,
        na = c("", "NA", "N/A", "-")
      )
    )
  }
)

# function
pluck_rbans_raw <- function(
    input_file_path,
    test_name_prefix,
    output_file_path = NULL) {
  df <- tryCatch(
    {
      suppressWarnings(
        readr::read_csv(
          input_file_path,
          col_names = FALSE,
          col_types = readr::cols(.default = "c"),
          show_col_types = FALSE,
          locale = readr::locale(encoding = "UTF-16LE"),
          skip_empty_rows = TRUE,
          trim_ws = TRUE,
          na = c("", "NA", "N/A", "-")
        )
      )
    },
    error = function(e) {
      # If read_csv fails, try with different encoding
      suppressWarnings(
        readr::read_csv(
          input_file_path,
          col_names = FALSE,
          col_types = readr::cols(.default = "c"),
          show_col_types = FALSE,
          skip_empty_rows = TRUE,
          trim_ws = TRUE,
          na = c("", "NA", "N/A", "-")
        )
      )
    }
  )

  # Rename the columns
  names(df) <- c("Subtest", "NA", "Raw score")

  # Remove the second column
  df <- df |> select(Subtest, `Raw score`)

  # Find the start of the "Raw Score" section
  start_line <- which(df == "RAW SCORES") + 1

  # Find the stop of the "Raw Score" section
  stop_line <- which(df == "SCALED SCORES") - 1

  # Read from the "Raw Score" section
  df_raw <- df |>
    dplyr::slice(start_line:stop_line)

  # Keep only rows with the specified prefix in the first column
  df_raw <- df_raw |> filter(str_starts(Subtest, test_name_prefix))

  # Your new names stored in a character vector (ensure it matches the number of columns in `df`)
  vars <- c("scale", "raw_score")

  # Use `set_names()` to rename the columns
  df_raw <- df_raw |> set_names(vars)
  df_raw$scale <- as.character(df_raw$scale)
  df_raw$raw_score <- as.numeric(df_raw$raw_score)

  # Write the combined data to a CSV file
  readr::write_csv(df_raw, output_file_path)

  return(df_raw)
}

# Run it
rbans_raw <- pluck_rbans_raw(
  input_file_path,
  test_name_prefix,
  output_file_path = output_file_path
)
```

## SCALED SCORES

```{r}
output_file_path <- "data-raw/processed_rbans_scaled_scores.csv"

# function
pluck_rbans_score <- function(
    input_file_path,
    test_name_prefix,
    output_file_path = NULL) {
  df <- tryCatch(
    {
      suppressWarnings(
        readr::read_csv(
          input_file_path,
          col_names = FALSE,
          col_types = readr::cols(.default = "c"),
          show_col_types = FALSE,
          locale = readr::locale(encoding = "UTF-16LE"),
          skip_empty_rows = TRUE,
          trim_ws = TRUE,
          na = c("", "NA", "N/A", "-")
        )
      )
    },
    error = function(e) {
      # If read_csv fails, try with different encoding
      suppressWarnings(
        readr::read_csv(
          input_file_path,
          col_names = FALSE,
          col_types = readr::cols(.default = "c"),
          show_col_types = FALSE,
          skip_empty_rows = TRUE,
          trim_ws = TRUE,
          na = c("", "NA", "N/A", "-")
        )
      )
    }
  )

  # Rename the columns
  names(df) <- c("Subtest", "NA", "Scaled score")

  # Remove the second column
  df <- df |> select(Subtest, `Scaled score`)

  # Find the start of the "Raw Score" section
  start_line <- which(df == "SCALED SCORES") + 1

  # Find the stop of the "Raw Score" section
  stop_line <- which(df == "CONTEXTUAL EVENTS") - 1

  # Read from the "score" section
  df_score <- df |>
    dplyr::slice(start_line:stop_line)

  # Keep only rows with the specified prefix in the first column
  df_score <- df_score |> filter(str_starts(Subtest, test_name_prefix))

  # Your new names stored in a character vector (ensure it matches the number of columns in `df`)
  vars <- c("scale", "score")

  # Use `set_names()` to rename the columns
  df_score <- df_score |> set_names(vars)
  df_score$scale <- as.character(df_score$scale)
  df_score$score <- as.numeric(df_score$score)

  # Write the combined data to a CSV file
  readr::write_csv(df_score, output_file_path)

  return(df_score)
}
rbans_score <- pluck_rbans_score(
  input_file_path,
  test_name_prefix,
  output_file_path = output_file_path
)
```

## SUBTEST COMPLETION TIMES

```{r}
output_file_path <- "data-raw/processed_rbans_completion_times.csv"

# function
pluck_rbans_completion_times <- function(
    input_file_path,
    test_name_prefix,
    output_file_path = NULL) {
  df <- tryCatch(
    {
      suppressWarnings(
        readr::read_csv(
          input_file_path,
          col_names = FALSE,
          col_types = readr::cols(.default = "c"),
          show_col_types = FALSE,
          locale = readr::locale(encoding = "UTF-16LE"),
          skip_empty_rows = TRUE,
          trim_ws = TRUE,
          na = c("", "NA", "N/A", "-")
        )
      )
    },
    error = function(e) {
      # If read_csv fails, try with different encoding
      suppressWarnings(
        readr::read_csv(
          input_file_path,
          col_names = FALSE,
          col_types = readr::cols(.default = "c"),
          show_col_types = FALSE,
          skip_empty_rows = TRUE,
          trim_ws = TRUE,
          na = c("", "NA", "N/A", "-")
        )
      )
    }
  )

  # Rename the columns
  names(df) <- c("Subtest", "NA", "Completion Time (seconds)")

  # Remove the second column
  df <- df |> select(Subtest, `Completion Time (seconds)`)

  # Find the start of the section
  start_line <- which(df == "SUBTEST COMPLETION TIMES") + 1

  # Find the stop of the section
  stop_line <- which(df == "RULES TRIGGERED") - 1

  # Read from the "Raw Score" section
  df_times <- df |>
    dplyr::slice(start_line:stop_line)

  # Keep only rows with the specified prefix in the first column
  df_times <- df_times |> filter(str_starts(Subtest, test_name_prefix))

  # Your new names stored in a character vector (ensure it matches the number of columns in `df`)
  vars <- c("scale", "completion_time_seconds")

  # Use `set_names()` to rename the columns
  df_times <- df_times |> set_names(vars)
  df_times$scale <- as.character(df_times$scale)
  df_times$completion_time_seconds <- as.numeric(
    df_times$completion_time_seconds
  )

  # Write the combined data to a CSV file
  write_csv(df_times, output_file_path)

  return(df_times)
}
rbans_time <- pluck_rbans_completion_times(
  input_file_path,
  test_name_prefix,
  output_file_path = output_file_path
)
```

## COMPOSITE SCORES

```{r}
output_file_path <- "data-raw/processed_rbans_composite_scores.csv"

# function
pluck_rbans_composite <- function(
    input_file_path,
    test_name_prefix,
    output_file_path = NULL) {
  df <- tryCatch(
    {
      suppressWarnings(
        readr::read_csv(
          input_file_path,
          col_names = FALSE,
          col_types = readr::cols(.default = "c"),
          show_col_types = FALSE,
          locale = readr::locale(encoding = "UTF-16LE"),
          skip_empty_rows = TRUE,
          trim_ws = TRUE,
          na = c("", "NA", "N/A", "-")
        )
      )
    },
    error = function(e) {
      # If read_csv fails, try with different encoding
      suppressWarnings(
        readr::read_csv(
          input_file_path,
          col_names = FALSE,
          col_types = readr::cols(.default = "c"),
          show_col_types = FALSE,
          skip_empty_rows = TRUE,
          trim_ws = TRUE,
          na = c("", "NA", "N/A", "-")
        )
      )
    }
  )

  # Assume the first row after "Composite Score" has the column names
  start_line <- which(df$X1 == "Composite Score")
  # Assuming there's no specific end line, use the end of the file
  stop_line <- nrow(df)

  # Extracting the relevant section
  df_composite <- df |>
    slice((start_line + 1):stop_line) |>
    tidyr::separate(
      X3,
      sep = ",",
      into = c(
        "percentile",
        "ci_90_lo",
        "ci_90_up",
        "ci_95_lower",
        "ci_95_upper"
      )
    ) |>
    slice(-1) |>
    rename(scale = X1, score = X2) |>
    # Filter based on the prefix
    filter(str_starts(scale, test_name_prefix)) |>
    select(-c(ci_90_lo, ci_90_up)) |>
    dplyr::mutate(
      scale = as.character(scale),
      score = as.numeric(score),
      percentile = as.numeric(percentile),
      ci_95_lower = as.numeric(ci_95_lower),
      ci_95_upper = as.numeric(ci_95_upper)
    )

  # Optionally write to a CSV file
  if (!is.null(output_file_path)) {
    readr::write_csv(df_composite, output_file_path)
  }

  return(df_composite)
}

rbans_composite <- pluck_rbans_composite(
  input_file_path,
  test_name_prefix,
  output_file_path = output_file_path
)
```

## MERGE Score Types

```{r}
output_file_path <- "data-raw/rbans_merged.csv"

#' Process and Save RBANS Data
#'
#' This function processes RBANS raw, score, and composite data frames by joining them,
#' updating specific values, and saving the combined data to a CSV file.
#'
#' @param rbans_raw A data frame containing raw RBANS data.
#' @param rbans_score A data frame containing RBANS scores.
#' @param rbans_time A df containing completion times.
#' @param rbans_composite A data frame containing RBANS composite scores.
#' @param test_name_prefix A string representing the prefix to be removed from the scale names.
#' @param output_file_path A string specifying the path to save the combined CSV file.
#' @import dplyr
#' @import stringr
#' @import neuro2
#' @export
process_and_save_rbans_data <- function(
    rbans_raw,
    rbans_score,
    rbans_time,
    rbans_composite,
    test_name_prefix,
    output_file_path) {
  
  # Join the data into one dataframe by the test name
  df <- dplyr::left_join(rbans_raw, rbans_score, by = "scale") |>
    dplyr::mutate(percentile = as.numeric(""), range = as.character("")) |>
    dplyr::left_join(rbans_time, by = "scale")
  
  # Recalculate percentiles based on score
  df <- df |>
    dplyr::mutate(z = ifelse(!is.na(score), (score - 10) / 3, NA)) |>
    dplyr::mutate(
      percentile = ifelse(is.na(percentile), trunc(pnorm(z) * 100), percentile)
    ) |>
    select(-z)
  
  # Merge with composite scores
  df <- bind_rows(df, rbans_composite) |>
    relocate(completion_time_seconds, .after = ci_95_upper)

  # Remove prefix from scale names
  df <- df |>
    dplyr::mutate(scale = str_remove(scale, test_name_prefix))
  
  scales_to_rename <- c(
    "Attention Index (ATI)" = "RBANS Attention Index",
    "Digit Span" = "RBANS Digit Span",
    "Coding" = "RBANS Coding",
    "Immediate Memory Index (IMI)" = "RBANS Immediate Memory Index",
    "List Learning" = "RBANS List Learning",
    "Story Memory" = "RBANS Story Memory",
    "Language Index (LGI)" = "RBANS Language Index",
    "Picture Naming" = "RBANS Picture Naming",
    "Semantic Fluency" = "RBANS Semantic Fluency",
    "Visuospatial/ Constructional Index (VCI)" = "RBANS Visuospatial/Constructional Index",
    "Figure Copy" = "RBANS Figure Copy",
    "Line Orientation" = "RBANS Line Orientation",
    "Delayed Memory Index (DRI)" = "RBANS Delayed Memory Index",
    "List Recall" = "RBANS List Recall",
    "List Recognition" = "RBANS List Recognition",
    "Story Recall" = "RBANS Story Recall",
    "Figure Recall" = "RBANS Figure Recall",
    "Total Scale (TOT)" = "RBANS Total Index"
  )
  
  df$scale <- purrr::map_chr(
    df$scale,
    ~ if_else(.x %in% names(scales_to_rename), scales_to_rename[.x], .x)
  )
  
  # Update specific percentile values
  df$percentile[
    df$scale == "RBANS Line Orientation"
  ] <- (params$line_orientation_pct_rank)
  df$percentile[
    df$scale == "RBANS Picture Naming"
  ] <- (params$picture_naming_pct_rank)
  df$percentile[
    df$scale == "RBANS List Recall"
  ] <- (params$list_recall_pct_rank)
  df$percentile[
    df$scale == "RBANS List Recognition"
  ] <- (params$list_recognition_pct_rank)
  
  # Test score ranges (assuming gpluck_make_score_ranges is a predefined function)
  df <- neuro2::gpluck_make_score_ranges(table = df, test_type = "npsych_test")
  
  # Write the combined data to a CSV file
  return(write_csv(df, output_file_path))
}

df <- process_and_save_rbans_data(
  rbans_raw = rbans_raw,
  rbans_score = rbans_score,
  rbans_time = rbans_time,
  rbans_composite = rbans_composite,
  test_name_prefix = test_name_prefix,
  output_file_path = output_file_path
)

# Write the combined data to a CSV file
readr::write_csv(df, output_file_path)
```

# MUTATE

```{r mutate}
rbans <- df

# Create ci_95 column if it doesn't exist
if (!("ci_95_lower" %in% names(rbans) && "ci_95_upper" %in% names(rbans))) {
  rbans$ci_95 <- NA_character_
} else {
  rbans$ci_95 <- ifelse(
    !is.na(rbans$ci_95_lower) & !is.na(rbans$ci_95_upper),
    paste0(rbans$ci_95_lower, "-", rbans$ci_95_upper),
    NA_character_
  )
}

# Ensure scale column is character type
if (!is.null(rbans$scale)) {
  rbans$scale <- as.character(rbans$scale)

  # Check for any list or complex objects in scale column
  if (any(sapply(rbans$scale, function(x) !is.atomic(x) || length(x) > 1))) {
    # Convert any problematic values to character
    rbans$scale <- sapply(rbans$scale, function(x) {
      if (!is.atomic(x) || length(x) > 1) {
        return(as.character(x)[1])
      } else {
        return(as.character(x))
      }
    })
  }
}
```

```{r lookup-table}
# rename
df2 <- rbans

# Load the lookup table
lookup_table <- readr::read_csv("~/Dropbox/neuropsych_lookup_table.csv")

# Merge with lookup table
df_merged <- dplyr::mutate(df2, test = test) |>
  dplyr::left_join(lookup_table, by = c("test" = "test", "scale" = "scale")) |>
  dplyr::select(-c(ci_95_lower, ci_95_upper, completion_time_seconds))

# Add missing columns
df_mutated <- neuro2::gpluck_make_columns(
  df_merged,
  result = ""
)

rbans <- df_mutated
```

## Glue results

```{r}
# Create result strings using glue
rbans <-
  rbans |>
  dplyr::mutate(
    result = ifelse(
      !is.na(scale) & !is.na(description) & !is.na(range),
      glue::glue("{patient}'s score on {scale} ({description}) was {range}."),
      NA_character_
    )
  )
```

# EXPORT

```{r}
readr::write_excel_csv(
  rbans,
  here::here("data-raw", "csv", "rbans.csv"),
  col_names = TRUE,
  na = ""
)
```

```{r}
cat("Finished!")
```
