---
title: "Create table and csv for DKEFS"
params:
  patient: Isabella
  test:
    label: "Test"
    value: dkefs
    input: select
    multiple: no
    choices:
      - dkefs
      - dkefs_cwi
      - dkefs_tmt
  test_name:
    label: "Test Name"
    value: "D-KEFS"
    input: select
    multiple: no
    choices: [D-KEFS, D-KEFS Color-Word Interference, D-KEFS Trail Making Test]
  file:
    label: "No file selected"
    value: file
    input: file
  eval: TRUE
  mean:
    label: "Mean:"
    value: 10
    input: radio
    choices: [0, 10, 50, 100]
  stdev:
    label: "Standard Deviation:"
    value: 3
    input: radio
    choices: [1, 3, 10, 15]
  reliability:
    label: "Reliability:"
    value: 0.90
    input: slider
    min: 0
    max: 1
    step: 0.01  
output:
  rmdformats::robobook:
    highlight: kate
---

# Data

This works with the raw SLK file from Q-interactive.

# Setup

```{r setup, include=F}
# Set JAVA environment
Sys.setenv(
  JAVA_HOME =
    "/Library/Java/JavaVirtualMachines/graalvm-jdk-22.0.1+8.1/Contents/Home"
)
options(java.parameters = "-Xmx16000m")
knitr::opts_chunk$set(
  root.dir = normalizePath("./"),
  echo = FALSE,
  eval = TRUE,
  include = TRUE,
  message = FALSE,
  warning = FALSE,
  error = TRUE
)
library(tidyverse)
library(tabulapdf)
library(rJava)
library(shiny)
library(here)
library(pdftools)
library(fs)
library(magrittr)
library(hablar)
library(googledrive)
library(neuro2)
```

## Patient

```{r patient}
patient <- params$patient
```

## Test

Name of neuropsych test or rating scale.

```{r test}
test <- params$test
test_name <- params$test_name
```

## Load text/csv file and save as file.path

```{r file}
# input_file_path <- file.path(file.choose())
input_file_path <- file.path(params$file)
saveRDS(input_file_path, file = "dkefs_input_file_path.rds")
```

## DKEFS Color-Word Interference Scores from SLK file

```{r}
library(tidyverse)
test_name_prefix <- "D-KEFS Color-Word Interference"
output_file_path <- "data/processed_dkefs_cwi_data.csv"

# function
pluck_dkefs_cwi <- function(input_file_path,
                            test_name_prefix,
                            output_file_path = NULL) {
  
  # Read the SYLK file as plain text lines
  lines <- readLines(input_file_path, encoding = "UTF-8")
  
  # Extract all cell content from SYLK format
  # Look for lines that start with "C;" which contain cell data
  cell_lines <- lines[grepl("^C;", lines)]
  
  # Create a data structure to store cells by position
  cells <- list()
  
  # Parse each cell line to extract position and value
  for (line in cell_lines) {
    # Extract row and column positions
    if (grepl("X([0-9]+)", line) && grepl("Y([0-9]+)", line)) {
      col <- as.numeric(gsub(".*X([0-9]+).*", "\\1", line))
      row <- as.numeric(gsub(".*Y([0-9]+).*", "\\1", line))
      
      # Extract value - could be text (K"...") or number (after last semicolon)
      if (grepl('K"', line)) {
        # Text value
        value <- gsub('.*K"([^"]*)".*', '\\1', line)
      } else {
        # Try to extract numeric value (usually at the end after last semicolon)
        parts <- strsplit(line, ";")[[1]]
        value <- parts[length(parts)]
        # Clean up any remaining characters
        value <- gsub("[^0-9.-]", "", value)
        if (value == "") value <- NA
      }
      
      # Store in our cells structure
      key <- paste(row, col, sep = "_")
      cells[[key]] <- list(row = row, col = col, value = value)
    }
  }
  
  # Convert to a more workable format
  if (length(cells) == 0) {
    stop("No cells found in SYLK file")
  }
  
  # Find the maximum row and column to create a matrix
  max_row <- max(sapply(cells, function(x) x$row))
  max_col <- max(sapply(cells, function(x) x$col))
  
  # Create a matrix to hold all values
  data_matrix <- matrix(NA, nrow = max_row, ncol = max_col)
  
  # Fill the matrix
  for (cell in cells) {
    data_matrix[cell$row, cell$col] <- cell$value
  }
  
  # Convert to data frame
  df <- as.data.frame(data_matrix, stringsAsFactors = FALSE)
  
  # Print for debugging
  cat("Extracted data matrix:\n")
  print(df)
  
  # Find the header row (should contain "D-KEFS Color-Word Interference Test")
  header_row <- which(apply(df, 1, function(x) any(grepl("D-KEFS Color-Word Interference", x, fixed = TRUE), na.rm = TRUE)))

if (length(header_row) == 0) {
  stop("Could not find D-KEFS Color-Word Interference Test header")
}
  
  # The column headers should be in the next row
  col_header_row <- header_row + 1
  
  # Extract column names from the header row
  if (col_header_row <= nrow(df)) {
    col_names <- df[col_header_row, ]
    col_names <- col_names[!is.na(col_names) & col_names != ""]
    
    # Use standard names if we don't find them in the file
    if (length(col_names) < 4) {
      col_names <- c("Subtest", "Raw Score", "Scaled Score", "Percentile Rank")
    }
  } else {
    col_names <- c("Subtest", "Raw Score", "Scaled Score", "Percentile Rank")
  }
  
  # Extract data rows (start after column headers)
  data_start_row <- col_header_row + 1
  data_rows <- df[data_start_row:nrow(df), 1:4, drop = FALSE]
  
  # Clean up the data - remove empty rows
  data_rows <- data_rows[!is.na(data_rows[,1]) & data_rows[,1] != "", ]
  
  # Set column names
  names(data_rows) <- c("scale", "raw_score", "score", "percentile")
  
  # Convert numeric columns
  data_rows$raw_score <- as.numeric(data_rows$raw_score)
  data_rows$score <- as.numeric(data_rows$score)
  data_rows$percentile <- as.numeric(data_rows$percentile)
  
  # Filter for rows that contain test names
  df_cwi <- data_rows[grepl("Color Naming|Word Reading|Inhibition", data_rows$scale), ]
  
  cat("Final extracted data:\n")
  print(df_cwi)

  # Write the combined data to a CSV file
  if (!is.null(output_file_path)) {
    write_excel_csv(df_cwi, output_file_path, na = "")
  }

  return(df_cwi)
}

df_cwi <- pluck_dkefs_cwi(input_file_path, test_name_prefix, output_file_path)
```

# MUTATE

## Create percentile

```{r percentile, eval = TRUE}
# TODO: Add percentile calculation ONLY if NA
df_cwi <- df_cwi |>
  dplyr::mutate(z = (score - 10) / 3) |>
  dplyr::mutate(percentile = ifelse(is.na(percentile), trunc(pnorm(z) * 100), percentile)) |>
  dplyr::select(-z)
```

```{r mutate}
dkefs <- df_cwi
dkefs <- neuro2::gpluck_make_columns(
  data = dkefs,
  test = params$test,
  test_name = params$test_name,
  range = "",
  # ci_95 = paste0(dkefs$ci_95_lower, "-", dkefs$ci_95_upper),
  domain = "",
  subdomain = "",
  narrow = "",
  pass = "",
  verbal = "",
  timed = "",
  test_type = "npsych_test",
  score_type = "scaled_score",
  description = "",
  result = ""
)
```

## Test score ranges

```{r ranges}
dkefs <- neuro2::gpluck_make_score_ranges(
  table = dkefs,
  test_type = "npsych_test"
)
```

## Domain

```{r domain}
dkefs <-
  dkefs |>
  dplyr::mutate(
    domain = dplyr::case_when(
      scale == "Color Naming" ~ "Verbal/Language",
      scale == "Word Reading" ~ "Verbal/Language",
      scale == "Inhibition" ~ "Attention/Executive",
      scale == "Inhibition/Switching" ~ "Attention/Executive",
      scale == "Color Naming Total Errors" ~ "Attention/Executive",
      scale == "Word Reading Total Errors" ~ "Attention/Executive",
      scale == "Inhibition Total Errors" ~ "Attention/Executive",
      scale == "Inhibition/Switching Total Errors" ~ "Attention/Executive",
      TRUE ~ domain
    )
  )
```

## Subdomain

```{r}
dkefs <-
  dkefs |>
  dplyr::mutate(
    subdomain = dplyr::case_when(
      scale == "Color Naming" ~ "Retrieval",
      scale == "Word Reading" ~ "Retrieval",
      scale == "Inhibition" ~ "Executive",
      scale == "Inhibition/Switching" ~ "Executive",
      scale == "Color Naming Total Errors" ~ "Attention",
      scale == "Word Reading Total Errors" ~ "Attention",
      scale == "Inhibition Total Errors" ~ "Attention",
      scale == "Inhibition/Switching Total Errors" ~ "Attention",
      TRUE ~ subdomain
    )
  )
```

## Narrow

```{r}
dkefs <-
  dkefs |>
  mutate(
    narrow = case_when(
      scale == "Color Naming" ~ "Naming Facility",
      scale == "Word Reading" ~ "Naming Facility",
      scale == "Inhibition" ~ "Inhibition",
      scale == "Inhibition/Switching" ~ "Set-Shifting",
      scale == "Color Naming Total Errors" ~ "Response Monitoring",
      scale == "Word Reading Total Errors" ~ "Response Monitoring",
      scale == "Inhibition Total Errors" ~ "Response Monitoring",
      scale == "Inhibition/Switching Total Errors" ~ "Response Monitoring",
      TRUE ~ narrow
    )
  )
```

## Timed/Untimed

```{r}
dkefs <-
  dkefs |>
  mutate(
    timed = case_when(
      scale == "Color Naming" ~ "Timed",
      scale == "Word Reading" ~ "Timed",
      scale == "Inhibition" ~ "Timed",
      scale == "Inhibition/Switching" ~ "Timed",
      scale == "Color Naming Total Errors" ~ "",
      scale == "Word Reading Total Errors" ~ "",
      scale == "Inhibition Total Errors" ~ "Timed",
      scale == "Inhibition/Switching Total Errors" ~ "Timed",
      TRUE ~ timed
    )
  )
```

## Verbal/Nonverbal

```{r}
dkefs <-
  dkefs |>
  mutate(
    verbal = case_when(
      scale == "Color Naming" ~ "Verbal",
      scale == "Word Reading" ~ "Verbal",
      scale == "Inhibition" ~ "Verbal",
      scale == "Inhibition/Switching" ~ "Verbal",
      scale == "Color Naming Total Errors" ~ "Verbal",
      scale == "Word Reading Total Errors" ~ "Verbal",
      scale == "Inhibition Total Errors" ~ "Verbal",
      scale == "Inhibition/Switching Total Errors" ~ "Verbal",
      TRUE ~ verbal
    )
  )
```

## PASS

```{r pass}
dkefs <-
  dkefs |>
  mutate(
    pass = case_when(
      scale == "Color Naming" ~ "Sequential",
      scale == "Word Reading" ~ "Sequential",
      scale == "Inhibition" ~ "Attention",
      scale == "Inhibition/Switching" ~ "Attention",
      scale == "Color Naming Total Errors" ~ "Attention",
      scale == "Word Reading Total Errors" ~ "Attention",
      scale == "Inhibition Total Errors" ~ "Attention",
      scale == "Inhibition/Switching Total Errors" ~ "Attention",
      TRUE ~ as.character(pass)
    )
  )
```

## Score type

```{r score-type}
dkefs <-
  dkefs |>
  mutate(
    score_type = case_when(
      scale == "Color Naming Total Errors" ~ "percentile",
      scale == "Word Reading Total Errors" ~ "percentile",
      TRUE ~ as.character(score_type)
    )
  )
```

## Descriptions

```{r}
dkefs <-
  dkefs |>
  mutate(
    description = case_when(
      scale == "Color Naming" ~ "Rapid color naming",
      scale == "Word Reading" ~ "Rapid word reading",
      scale == "Inhibition" ~ "Inhibition/cognitive control",
      scale == "Inhibition/Switching" ~ "Set-shifting/cognitive flexibility",
      scale == "Color Naming Total Errors" ~ "Color naming errors",
      scale == "Word Reading Total Errors" ~ "Word reading errors",
      scale == "Inhibition Total Errors" ~ "Inhibition errors",
      scale == "Inhibition/Switching Total Errors" ~ "Switching errors",
      TRUE ~ as.character(description)
    )
  )
```

## Glue results

```{r}
dkefs <-
  dkefs |>
  dplyr::mutate(
    result = glue::glue("{patient}'s score on {.data$scale} ({.data$description}) was {.data$range}.")
  )
```

## Relocate variables

```{r relocate}
dkefs <-
  dkefs |>
  dplyr::relocate(c(raw_score, score, percentile, range, ci_95), .after = scale)
```

# EXPORT

```{r}
readr::write_csv(dkefs, here::here("data-raw", "csv", "dkefs.csv"), col_names = TRUE, na = "")
```

## Write to "g"

```{r}
has_headers <- function(file_path) {
  if (!file.exists(file_path)) {
    return(FALSE) # File doesn't exist, headers are needed
  }
  # Check if the file has at least one line (header)
  return(length(readLines(file_path, n = 1)) > 0)
}
```

```{r writeout-g}
table <- dkefs
test <- "g"
file_path <- here::here("data-raw", paste0(test, ".csv"))

readr::write_excel_csv(
  table,
  file_path,
  append = TRUE,
  col_names = !has_headers(file_path),
  quote = "none"
)
```

```{r}
cat("Finished!")
```
